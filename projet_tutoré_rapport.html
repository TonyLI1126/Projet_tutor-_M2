<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tony LI - Saïd BENAISSA">

<title>PROJET TUTORE M2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="projet_tutoré_rapport_files/libs/clipboard/clipboard.min.js"></script>
<script src="projet_tutoré_rapport_files/libs/quarto-html/quarto.js"></script>
<script src="projet_tutoré_rapport_files/libs/quarto-html/popper.min.js"></script>
<script src="projet_tutoré_rapport_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="projet_tutoré_rapport_files/libs/quarto-html/anchor.min.js"></script>
<link href="projet_tutoré_rapport_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="projet_tutoré_rapport_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="projet_tutoré_rapport_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="projet_tutoré_rapport_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="projet_tutoré_rapport_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">PROJET TUTORE M2</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Tony LI - Saïd BENAISSA </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="projet-tutoré-mouvement-brownien-anova-phylogénie" class="level1">
<h1>Projet tutoré : Mouvement brownien, ANOVA, phylogénie…</h1>
<section id="larbre-phylogénétique" class="level2">
<h2 class="anchored" data-anchor-id="larbre-phylogénétique">L’arbre phylogénétique</h2>
<p>Nous considérons un arbre phylogénétique représentant les relations évolutives entre quatre feuilles issues d’un ancêtre commun A0.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ape)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(phytools)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Le chargement a nécessité le package : maps</code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attachement du package : 'dplyr'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>L'objet suivant est masqué depuis 'package:ape':

    where</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Les objets suivants sont masqués depuis 'package:stats':

    filter, lag</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Les objets suivants sont masqués depuis 'package:base':

    intersect, setdiff, setequal, union</code></pre>
</div>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(purrr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attachement du package : 'purrr'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>L'objet suivant est masqué depuis 'package:maps':

    map</code></pre>
</div>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>n_tips <span class="ot">=</span> <span class="dv">5</span>  <span class="co"># nombre d'espèces terminales</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>lambda <span class="ot">=</span> <span class="dv">1</span>   <span class="co"># taux de spéciation (naissance)</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>mu <span class="ot">=</span> <span class="dv">0</span>       <span class="co"># taux d'extinction (0 = pur birth)</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>tree<span class="ot">=</span> <span class="fu">rphylo</span>(<span class="at">n =</span> n_tips, <span class="at">birth =</span> lambda, <span class="at">death =</span> mu)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(tree, <span class="at">show.tip.label =</span> <span class="cn">TRUE</span>, <span class="at">cex =</span> <span class="fl">0.9</span>, <span class="at">main =</span> <span class="st">"Arbre simulé avec rphylo()"</span>)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="fu">edgelabels</span>()</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="fu">nodelabels</span>()</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="fu">tiplabels</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_tutoré_rapport_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>simulate_bm <span class="ot">&lt;-</span> <span class="cf">function</span>(t_e, N) {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 1. choose a regular grid on [0,T] with step dt = t_e / N</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  dt <span class="ot">&lt;-</span> t_e <span class="sc">/</span> N</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, t_e, dt)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 2. define data frame and set W_0 = 0</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  traj <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">time =</span> time, <span class="at">value =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, N<span class="sc">+</span><span class="dv">1</span>))</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  traj<span class="sc">$</span>value[<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 3. simulate increments dW_n ~ N(0, dt) for 1 &lt;= n &lt;= N</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  dW <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, N)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N) {</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    dW[n] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">1</span>, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="fu">sqrt</span>(dt))</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 4. write W_n = \sum_{i=1}^n dW_i for 1 &lt;= n &lt;= N in the dataframe</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  traj<span class="sc">$</span>value[<span class="sc">-</span><span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">cumsum</span>(dW)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># return dataframe</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(traj)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="do">## choose a time step</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>dt <span class="ot">&lt;-</span> <span class="fl">0.001</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="do">## choose starting value</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fl">1.3</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="do">## Create a data frame with the simulated trajectory</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>dftree <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">value =</span> <span class="fu">numeric</span>(<span class="dv">0</span>),       <span class="co"># position of the BM</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>                     <span class="at">time =</span> <span class="fu">numeric</span>(<span class="dv">0</span>),        <span class="co"># time elapsed since root</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>                     <span class="at">edge =</span> <span class="fu">numeric</span>(<span class="dv">0</span>))        <span class="co"># number of the edge of the tree</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="do">## traverse the tree from edge to edge</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(tree<span class="sc">$</span>edge)) {</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># simulate a BM starting at (0,0) on the current branch</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  t_branch <span class="ot">&lt;-</span> tree<span class="sc">$</span>edge.length[i]</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>  N_branch <span class="ot">&lt;-</span> <span class="fu">floor</span>(t_branch <span class="sc">/</span> dt)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  current_BM <span class="ot">&lt;-</span> <span class="fu">simulate_bm</span>(t_branch, N_branch)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># find the parent edge of the starting node of the current edge</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>  parent_edge <span class="ot">&lt;-</span> <span class="fu">which</span>(tree<span class="sc">$</span>edge[i, <span class="dv">1</span>] <span class="sc">==</span> tree<span class="sc">$</span>edge[, <span class="dv">2</span>])</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># case where current edge does not a parent edge</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">length</span>(parent_edge) <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add starting value mu</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    current_BM<span class="sc">$</span>value <span class="ot">&lt;-</span> current_BM<span class="sc">$</span>value <span class="sc">+</span> mu</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> { <span class="co"># case where current edge do have a parent edge</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># find last value on the parent branch</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    dfparent <span class="ot">&lt;-</span> dftree[dftree<span class="sc">$</span>edge <span class="sc">==</span> parent_edge, ]</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    last_parent <span class="ot">&lt;-</span> dfparent[<span class="fu">nrow</span>(dfparent), ]</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add last value of parent as starting value of the branch</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    current_BM<span class="sc">$</span>value <span class="ot">&lt;-</span> current_BM<span class="sc">$</span>value <span class="sc">+</span> last_parent<span class="sc">$</span>value</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    current_BM<span class="sc">$</span>time <span class="ot">&lt;-</span> current_BM<span class="sc">$</span>time <span class="sc">+</span> last_parent<span class="sc">$</span>time</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>  <span class="co"># fill in the dataframe</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>  dfbranch <span class="ot">&lt;-</span>  <span class="fu">data.frame</span>(<span class="at">value =</span> current_BM<span class="sc">$</span>value,</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>                          <span class="at">time =</span> current_BM<span class="sc">$</span>time,</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>                          <span class="at">edge =</span> i)</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>  <span class="co"># update dftree</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>  dftree <span class="ot">&lt;-</span> <span class="fu">rbind</span>(dftree, dfbranch)</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(dftree, <span class="fu">aes</span>(time, value, <span class="at">color =</span> <span class="fu">as.factor</span>(edge))) <span class="sc">+</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_path</span>(<span class="at">linewidth =</span> <span class="dv">1</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>p</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_tutoré_rapport_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>On peut décrire l’évolution d’un caractère quantitatif <strong>T</strong> (par ex. la taille d’une feuille) par un mouvement brownien au cours du temps évolutif <strong>t</strong> (dans le cas de la phylogénie).</p>
<p>Mouvement brownien appliqué à l’évolution d’un caractère continu le long d’un arbre phylogénétique</p>
<p>Le mouvement brownien est un processus stochastique fondamental servant de modèle pour décrire l’évolution aléatoire d’un caractère continu au cours du temps. Il s’agit du processus le plus simple vérifiant les propriétés suivantes : - il est <strong>continu</strong> presque sûrement ; - il possède des accroissements indépendants et stationnaires ; - chaque accroissement est gaussien de moyenne nulle.</p>
<p>On appelle mouvement brownien standard <span class="math inline">\(((B_t)_{t \ge 0})\)</span> le processus stochastique tel que :</p>
<span class="math display">\[\begin{cases}
B_0 = 0,\\[4pt]
B_t - B_s \sim \mathcal{N}(0, t-s), \quad \text{pour } 0 \le s &lt; t,\\[4pt]
\text{les accroissements sont indépendants.}
\end{cases}\]</span>
</section>
<section id="covariance-sous-mouvement-brownien-sur-un-arbre" class="level2">
<h2 class="anchored" data-anchor-id="covariance-sous-mouvement-brownien-sur-un-arbre">Covariance sous mouvement brownien sur un arbre</h2>
<p>On considère un arbre enraciné, où chaque feuille <span class="math inline">\(i\)</span> est reliée à la racine par un chemin de longueur <span class="math inline">\(t_i\)</span>.<br>
Pour deux feuilles <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span>, on note <span class="math inline">\(t_{ij}\)</span> la longueur du chemin commun depuis la racine jusqu’au MRCA (dernier ancêtre commun).</p>
<p>Le caractère évolue le long de l’arbre selon un mouvement brownien, avec valeur moyenne <span class="math inline">\(\mu\)</span> à la racine.</p>
<p>Modèle utilisé:</p>
<p>On note la valeur du caractère au MRCA de <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span> par <span class="math inline">\(Z_{ij}\)</span>, alors :</p>
<p><span class="math display">\[
Z_{ij} \sim \mathcal{N}(\mu,\; \sigma^2 t_{ij})
\]</span></p>
<p>et les valeurs terminales <span class="math inline">\(Y_i\)</span> et <span class="math inline">\(Y_j\)</span> s’écrivent :</p>
<p><span class="math display">\[
Y_i \mid Z_{ij} \sim \mathcal{N}(Z_{ij},\; \sigma^2 (t_i - t_{ij}))
\]</span></p>
<p><span class="math display">\[
Y_j \mid Z_{ij} \sim \mathcal{N}(Z_{ij},\; \sigma^2 (t_j - t_{ij}))
\]</span></p>
<p>Autrement dit, on peut écrire :</p>
<p><span class="math display">\[
Y_i = Z_{ij} + \varepsilon_i, \quad \varepsilon_i \sim \mathcal{N}(0,\; \sigma^2 (t_i - t_{ij}))
\]</span></p>
<p><span class="math display">\[
Y_j = Z_{ij} + \varepsilon_j, \quad \varepsilon_j \sim \mathcal{N}(0,\; \sigma^2 (t_j - t_{ij}))
\]</span>Indépendance des composantes:</p>
<p>Le mouvement brownien nous assure que :</p>
<p>- <span class="math inline">\(Z_{ij}\)</span> dépend uniquement de l’évolution du caractère sur les branches commune (jusqu’au MRCA),<br>
- <span class="math inline">\(\varepsilon_i\)</span> dépend des accroissements après la séparation, sur la branche propre à <span class="math inline">\(i\)</span>,<br>
- <span class="math inline">\(\varepsilon_j\)</span> dépend des accroissements après la séparation, sur la branche propre à <span class="math inline">\(j\)</span>.</p>
<p>Comme ces ensembles de branches sont disjoints, on a :</p>
<p><span class="math display">\[
Z_{ij} \perp \varepsilon_i, \quad Z_{ij} \perp \varepsilon_j, \quad \varepsilon_i \perp \varepsilon_j
\]</span>Calcul de la covariance:</p>
<p>On développe : <span class="math display">\[
\operatorname{Cov}(Y_i, Y_j)
= \operatorname{Cov}(Z_{ij} + \varepsilon_i,\; Z_{ij} + \varepsilon_j)
\]</span></p>
<p>Par bilinéarité de la covariance : <span class="math display">\[
\operatorname{Cov}(Y_i, Y_j)
= \operatorname{Cov}(Z_{ij}, Z_{ij})
+ \operatorname{Cov}(Z_{ij}, \varepsilon_j)
+ \operatorname{Cov}(\varepsilon_i, Z_{ij})
+ \operatorname{Cov}(\varepsilon_i, \varepsilon_j)
\]</span></p>
<p>Les trois derniers termes sont nuls par indépendance (vu en haut): <span class="math display">\[
\operatorname{Cov}(Z_{ij}, \varepsilon_j)
= \operatorname{Cov}(\varepsilon_i, Z_{ij})
= \operatorname{Cov}(\varepsilon_i, \varepsilon_j)
= 0.
\]</span></p>
<p>Il reste donc : <span class="math display">\[
\operatorname{Cov}(Y_i, Y_j)
= \operatorname{Var}(Z_{ij})
= \sigma^2 t_{ij}.
\]</span>Conclusion</p>
<p><span class="math display">\[
\operatorname{Cov}(Y_i, Y_j) = \sigma^2\, t_{ij}
\]</span></p>
<p>Etape suivante formule beta etc</p>
</section>
<section id="estimation-de-beta-dans-la-régression-phylogénétique" class="level2">
<h2 class="anchored" data-anchor-id="estimation-de-beta-dans-la-régression-phylogénétique">Estimation de <span class="math inline">\(\beta\)</span> dans la régression phylogénétique</h2>
<p>On considère le modèle linéaire :</p>
<p><span class="math display">\[
Y = X\beta + \sigma \varepsilon,
\qquad \varepsilon \sim \mathcal N(0,\,C)
\]</span></p>
<p>où <span class="math inline">\(Y\)</span> est le vecteur des observations, <span class="math inline">\(X\)</span> la matrice de design, <span class="math inline">\(\beta\)</span> le vecteur de paramètres, et <span class="math inline">\(C\)</span> la matrice de covariance phylogénétique.</p>
<section id="cas-classique-erreurs-indépendantes" class="level3">
<h3 class="anchored" data-anchor-id="cas-classique-erreurs-indépendantes">Cas classique : erreurs indépendantes</h3>
<p>Si <span class="math inline">\(\varepsilon \sim \mathcal N(0, I)\)</span>, alors l’estimation par moindres carrés consiste à minimiser:</p>
<p><span class="math display">\[
Q(\beta)=\|Y - X\beta\|^2
= (Y - X\beta)^\top (Y - X\beta).
\]</span></p>
<p>On développe terme à terme:</p>
<p><span class="math display">\[
Q(\beta) = Y^\top Y - 2\beta^\top X^\top Y + \beta^\top X^\top X\,\beta.
\]</span></p>
<p>On dérive par rapport à <span class="math inline">\(\beta\)</span> :</p>
<p><span class="math display">\[
\frac{\partial Q}{\partial \beta}
= -2X^\top Y + 2X^\top X\,\beta.
\]</span></p>
<p>En annulant l’équation, on obtient :</p>
<p><span class="math display">\[
X^\top (Y - X\hat\beta) = 0
\quad \Longrightarrow \quad
X^\top X\,\hat\beta = X^\top Y.
\]</span></p>
<p>Donc l’estimateur dans le cas classique est :</p>
<p><span class="math display">\[
\hat\beta_{\text{OLS}} = (X^\top X)^{-1} X^\top Y.
\]</span></p>
</section>
<section id="cas-phylogénétique-erreurs-corrélées" class="level3">
<h3 class="anchored" data-anchor-id="cas-phylogénétique-erreurs-corrélées">Cas phylogénétique : erreurs corrélées</h3>
<p>Maintenant, les erreurs suivent <span class="math inline">\(\varepsilon \sim \mathcal N(0,\,C)\)</span>, donc les observations sont corrélées mais on connait <span class="math inline">\(C\)</span> grâce à l’arbre, qui est la covariance phylogénétique sous MB.</p>
<p>On utilise la décomposition de Cholesky :</p>
<p><span class="math display">\[
C = LL^\top.
\]</span></p>
<p>On remplace et réécrit en fonction des <span class="math inline">\(L\)</span> :</p>
<p><span class="math display">\[
\tilde Y = L^{-1}Y,
\qquad
\tilde X = L^{-1}X,
\qquad
\tilde\varepsilon = L^{-1}\varepsilon.
\]</span></p>
<p>Alors:</p>
<p><span class="math display">\[
\tilde Y = \tilde X\beta + \sigma\tilde\varepsilon,
\qquad
\tilde\varepsilon \sim \mathcal N(0, I).
\]</span></p>
<p>On a donc un modèle linéaire classique sur les données transformées et on peut appliquer les mêmes méthodes que dans le cas classiques.</p>
<section id="estimateurs-de-beta-dans-le-cas-phylogénétique" class="level4">
<h4 class="anchored" data-anchor-id="estimateurs-de-beta-dans-le-cas-phylogénétique">Estimateurs de <span class="math inline">\(\beta\)</span> dans le cas phylogénétique</h4>
<p>On minimise:</p>
<p><span class="math display">\[
\tilde Q(\beta)
=\|\tilde Y - \tilde X\beta\|^2
=(\tilde Y - \tilde X\beta)^\top(\tilde Y - \tilde X\beta).
\]</span></p>
<p>On développe terme à terme:</p>
<p><span class="math display">\[
\tilde Q(\beta)
= \tilde Y^\top \tilde Y
- 2\,\beta^\top \tilde X^\top \tilde Y
+ \beta^\top \tilde X^\top \tilde X\,\beta.
\]</span></p>
<p>On dérive par rapport à <span class="math inline">\(\beta\)</span> :</p>
<p><span class="math display">\[
\frac{\partial \tilde Q}{\partial \beta}
= -2\,\tilde X^\top \tilde Y + 2\,\tilde X^\top \tilde X\,\beta.
\]</span></p>
<p>On cherche à annuler cette équation et on trouve la forme:</p>
<p><span class="math display">\[
\tilde X^\top \tilde X\,\hat\beta
= \tilde X^\top \tilde Y.
\]</span></p>
<p>Donc en isolant <span class="math inline">\(\beta\)</span> :</p>
<p><span class="math display">\[
\hat\beta
= (\tilde X^\top \tilde X)^{-1} \tilde X^\top \tilde Y.
\]</span></p>
<p>Avec <span class="math inline">\(\tilde X = L^{-1}X\)</span> et <span class="math inline">\(\tilde Y = L^{-1}Y\)</span> , on remplace:</p>
<p><span class="math display">\[
\tilde X^\top \tilde X
= X^\top (L^{-1})^\top L^{-1} X
= X^\top C^{-1} X,
\qquad
\tilde X^\top \tilde Y
= X^\top (L^{-1})^\top L^{-1} Y
= X^\top C^{-1} Y,
\]</span></p>
<p>puisque <span class="math inline">\((L^{-1})^\top L^{-1}=(LL^\top)^{-1}=C^{-1}\)</span> :</p>
<p>On a finalement:</p>
<p><span class="math display">\[
\boxed{
\hat\beta = (X^\top C^{-1}X)^{-1} X^\top C^{-1}Y
}
\]</span></p>
<p>On a l’estimateur de <span class="math inline">\(\beta\)</span> qui est celui des moindres carrés généralisés</p>
</section>
</section>
</section>
<section id="estimation-de-sigma2-dans-la-régression-phylogénétique" class="level2">
<h2 class="anchored" data-anchor-id="estimation-de-sigma2-dans-la-régression-phylogénétique">Estimation de <span class="math inline">\(\sigma^2\)</span> dans la régression phylogénétique</h2>
<p>On considère le modèle linéaire :</p>
<p><span class="math display">\[
Y = X\beta + \sigma \varepsilon, \qquad \varepsilon \sim \mathcal N(0,\,C)
\]</span></p>
<p>où <span class="math inline">\(Y\)</span> est le vecteur des observations, <span class="math inline">\(X\)</span> la matrice de design, <span class="math inline">\(\beta\)</span> le vecteur de paramètres, et <span class="math inline">\(C\)</span> la matrice de covariance phylogénétique.</p>
<section id="cas-classique-erreurs-indépendantes-1" class="level3">
<h3 class="anchored" data-anchor-id="cas-classique-erreurs-indépendantes-1">Cas classique : erreurs indépendantes</h3>
<p>Dans le cas <span class="math inline">\(\varepsilon \sim \mathcal N(0,I)\)</span>, on définit le résidu:</p>
<p><span class="math display">\[
\hat r = Y - X\hat\beta_{\text{OLS}},
\qquad \hat\beta_{\text{OLS}} = (X^\top X)^{-1}X^\top Y.
\]</span></p>
<p>L’estimateur non biaisé de <span class="math inline">\(\sigma^2\)</span> est :</p>
<p><span class="math display">\[
\boxed{\ \hat\sigma^2_{\text{OLS}}
= \frac{1}{n-p}\,\|Y - X\hat\beta_{\text{OLS}}\|^2
= \frac{1}{n-p}\,(Y-X\hat\beta_{\text{OLS}})^\top (Y-X\hat\beta_{\text{OLS}})\ }.
\]</span></p>
</section>
<section id="cas-phylogénétique-erreurs-corrélées-1" class="level3">
<h3 class="anchored" data-anchor-id="cas-phylogénétique-erreurs-corrélées-1">Cas phylogénétique : erreurs corrélées</h3>
<p>Ici <span class="math inline">\(\varepsilon \sim \mathcal N(0,C)\)</span>.<br>
On note la décomposition de Cholesky :</p>
<p><span class="math display">\[
C = LL^\top.
\]</span></p>
<p>Comme pour l’estimation de <span class="math inline">\(\beta\)</span> on a donc :</p>
<p><span class="math display">\[
\tilde Y = L^{-1}Y, \qquad \tilde X = L^{-1}X, \qquad \tilde\varepsilon = L^{-1}\varepsilon \sim \mathcal N(0,I).
\]</span></p>
<p>Le modèle devient donc:</p>
<p><span class="math display">\[
\tilde Y = \tilde X\beta + \sigma\tilde\varepsilon.
\]</span></p>
<p>et l’estimateur de <span class="math inline">\(\beta\)</span> GLS devient:</p>
<p><span class="math display">\[
\hat\beta = (X^\top C^{-1}X)^{-1}X^\top C^{-1}Y.
\]</span></p>
<p>On définit les résidus :</p>
<p><span class="math display">\[
\hat r = Y - X\hat\beta,
\qquad
\tilde r = \tilde Y - \tilde X \hat\beta = L^{-1}\hat r.
\]</span></p>
<p>Alors :</p>
<p><span class="math display">\[
\hat\sigma^2
= \frac{1}{n-p}\|\tilde r\|^2
= \frac{1}{n-p}\,(\tilde Y - \tilde X\hat\beta)^\top(\tilde Y - \tilde X\hat\beta).
\]</span></p>
<p>En remplaçant <span class="math inline">\(\tilde r = L^{-1}\hat r\)</span> :</p>
<p><span class="math display">\[
\begin{aligned}
\|\tilde r\|^2
&amp;= (L^{-1}\hat r)^\top(L^{-1}\hat r) \\
&amp;= \hat r^\top (L^{-1})^\top L^{-1} \hat r \\
&amp;= \hat r^\top (LL^\top)^{-1} \hat r \\
&amp;= \hat r^\top C^{-1} \hat r
= (Y - X\hat\beta)^\top C^{-1}(Y - X\hat\beta).
\end{aligned}
\]</span></p>
<p>et au final on a :</p>
<p><span class="math display">\[
\boxed{
\hat\sigma^2
= \frac{1}{n-p}(Y - X\hat\beta)^\top C^{-1}(Y - X\hat\beta)
= \frac{1}{n-p}\|\tilde Y - \tilde X\hat\beta\|^2
}.
\]</span></p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>