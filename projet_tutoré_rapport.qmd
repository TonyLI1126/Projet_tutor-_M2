---
title: "PROJET TUTORE M2"
format: pdf
editor: visual
author: Tony LI - Saïd BENAISSA
---

# Projet tutoré : Mouvement brownien, ANOVA, phylogénie...

## L'arbre phylogénétique

Nous considérons un arbre phylogénétique représentant les relations évolutives entre quatre feuilles issues d’un ancêtre commun A0.

```{r}
library(ape)
library(phytools)
library(dplyr)
library(purrr)
library(ggplot2)
library(here)
library(microbenchmark)


n_tips = 5  # nombre d'espèces terminales
lambda = 1   # taux de spéciation (naissance)
mu = 0       # taux d'extinction (0 = pur birth)

tree= rphylo(n = n_tips, birth = lambda, death = mu)
plot(tree, show.tip.label = TRUE, cex = 0.9, main = "Arbre simulé avec rphylo()")
edgelabels()
nodelabels()
tiplabels()
```

```{r}
simulate_bm <- function(t_e, N) {
  # 1. choose a regular grid on [0,T] with step dt = t_e / N
  dt <- t_e / N
  time <- seq(0, t_e, dt)
  # 2. define data frame and set W_0 = 0
  traj <- data.frame(time = time, value = rep(NA, N+1))
  traj$value[1] <- 0
  # 3. simulate increments dW_n ~ N(0, dt) for 1 <= n <= N
  dW <- rep(NA, N)
  for (n in 1:N) {
    dW[n] <- rnorm(1, mean = 0, sd = sqrt(dt))
  }
  # 4. write W_n = \sum_{i=1}^n dW_i for 1 <= n <= N in the dataframe
  traj$value[-1] <- cumsum(dW)
  # return dataframe
  return(traj)
}
```

```{r}
## choose a time step
dt <- 0.001
## choose starting value
mu <- 1.3
## Create a data frame with the simulated trajectory
dftree <- data.frame(value = numeric(0),       # position of the BM
                     time = numeric(0),        # time elapsed since root
                     edge = numeric(0))        # number of the edge of the tree
## traverse the tree from edge to edge
for (i in 1:nrow(tree$edge)) {
  # simulate a BM starting at (0,0) on the current branch
  t_branch <- tree$edge.length[i]
  N_branch <- floor(t_branch / dt)
  current_BM <- simulate_bm(t_branch, N_branch)
  # find the parent edge of the starting node of the current edge
  parent_edge <- which(tree$edge[i, 1] == tree$edge[, 2])
  # case where current edge does not a parent edge
  if (length(parent_edge) == 0) {
    # add starting value mu
    current_BM$value <- current_BM$value + mu
  } else { # case where current edge do have a parent edge
    # find last value on the parent branch
    dfparent <- dftree[dftree$edge == parent_edge, ]
    last_parent <- dfparent[nrow(dfparent), ]
    # add last value of parent as starting value of the branch
    current_BM$value <- current_BM$value + last_parent$value
    current_BM$time <- current_BM$time + last_parent$time
  }
  # fill in the dataframe
  dfbranch <-  data.frame(value = current_BM$value,
                          time = current_BM$time,
                          edge = i)
  # update dftree
  dftree <- rbind(dftree, dfbranch)
}
```

```{r}
p <- ggplot(dftree, aes(time, value, color = as.factor(edge))) +
  geom_path(linewidth = 1)
p
```

On peut décrire l’évolution d’un caractère quantitatif **T** (par ex. la taille d’une feuille) par un mouvement brownien au cours du temps évolutif **t** (dans le cas de la phylogénie).

Mouvement brownien appliqué à l'évolution d'un caractère continu le long d'un arbre phylogénétique

Le mouvement brownien est un processus stochastique fondamental servant de modèle pour décrire l’évolution aléatoire d’un caractère continu au cours du temps. Il s’agit du processus le plus simple vérifiant les propriétés suivantes : - il est **continu** presque sûrement ; - il possède des accroissements indépendants et stationnaires ; - chaque accroissement est gaussien de moyenne nulle.

On appelle mouvement brownien standard $((B_t)_{t \ge 0})$ le processus stochastique tel que :

$$
\begin{cases}
B_0 = 0,\\[4pt]
B_t - B_s \sim \mathcal{N}(0, t-s), \quad \text{pour } 0 \le s < t,\\[4pt]
\text{les accroissements sont indépendants.}
\end{cases}
$$

## Covariance sous mouvement brownien sur un arbre

On considère un arbre enraciné, où chaque feuille $i$ est reliée à la racine par un chemin de longueur $t_i$.\
Pour deux feuilles $i$ et $j$, on note $t_{ij}$ la longueur du chemin commun depuis la racine jusqu’au MRCA (dernier ancêtre commun).

Le caractère évolue le long de l’arbre selon un mouvement brownien, avec valeur moyenne $\mu$ à la racine.

Modèle utilisé:

On note la valeur du caractère au MRCA de $i$ et $j$ par $Z_{ij}$, alors :

$$
Z_{ij} \sim \mathcal{N}(\mu,\; \sigma^2 t_{ij})
$$

et les valeurs terminales $Y_i$ et $Y_j$ s’écrivent :

$$
Y_i \mid Z_{ij} \sim \mathcal{N}(Z_{ij},\; \sigma^2 (t_i - t_{ij}))
$$

$$
Y_j \mid Z_{ij} \sim \mathcal{N}(Z_{ij},\; \sigma^2 (t_j - t_{ij}))
$$

Autrement dit, on peut écrire :

$$
Y_i = Z_{ij} + \varepsilon_i, \quad \varepsilon_i \sim \mathcal{N}(0,\; \sigma^2 (t_i - t_{ij}))
$$

$$
Y_j = Z_{ij} + \varepsilon_j, \quad \varepsilon_j \sim \mathcal{N}(0,\; \sigma^2 (t_j - t_{ij}))
$$Indépendance des composantes:

Le mouvement brownien nous assure que :

\- $Z_{ij}$ dépend uniquement de l’évolution du caractère sur les branches commune (jusqu’au MRCA),\
- $\varepsilon_i$ dépend des accroissements après la séparation, sur la branche propre à $i$,\
- $\varepsilon_j$ dépend des accroissements après la séparation, sur la branche propre à $j$.

Comme ces ensembles de branches sont disjoints, on a :

$$
Z_{ij} \perp \varepsilon_i, \quad Z_{ij} \perp \varepsilon_j, \quad \varepsilon_i \perp \varepsilon_j
$$Calcul de la covariance:

On développe : $$
\operatorname{Cov}(Y_i, Y_j)
= \operatorname{Cov}(Z_{ij} + \varepsilon_i,\; Z_{ij} + \varepsilon_j)
$$

Par bilinéarité de la covariance : $$
\operatorname{Cov}(Y_i, Y_j)
= \operatorname{Cov}(Z_{ij}, Z_{ij})
+ \operatorname{Cov}(Z_{ij}, \varepsilon_j)
+ \operatorname{Cov}(\varepsilon_i, Z_{ij})
+ \operatorname{Cov}(\varepsilon_i, \varepsilon_j)
$$

Les trois derniers termes sont nuls par indépendance (vu en haut): $$
\operatorname{Cov}(Z_{ij}, \varepsilon_j)
= \operatorname{Cov}(\varepsilon_i, Z_{ij})
= \operatorname{Cov}(\varepsilon_i, \varepsilon_j)
= 0.
$$

Il reste donc : $$
\operatorname{Cov}(Y_i, Y_j)
= \operatorname{Var}(Z_{ij})
= \sigma^2 t_{ij}.
$$Conclusion

$$
\operatorname{Cov}(Y_i, Y_j) = \sigma^2\, t_{ij}
$$

Etape suivante formule beta etc

## Estimation de $\beta$ dans la régression phylogénétique

On considère le modèle linéaire :

$$
Y = X\beta + \sigma \varepsilon, 
\qquad \varepsilon \sim \mathcal N(0,\,C)
$$

où $Y$ est le vecteur des observations, $X$ la matrice de design, $\beta$ le vecteur de paramètres, et $C$ la matrice de covariance phylogénétique.

### Cas classique : erreurs indépendantes

Si $\varepsilon \sim \mathcal N(0, I)$, alors l'estimation par moindres carrés consiste à minimiser:

$$
Q(\beta)=\|Y - X\beta\|^2
= (Y - X\beta)^\top (Y - X\beta).
$$

On développe terme à terme:

$$
Q(\beta) = Y^\top Y - 2\beta^\top X^\top Y + \beta^\top X^\top X\,\beta.
$$

On dérive par rapport à $\beta$ :

$$
\frac{\partial Q}{\partial \beta}
= -2X^\top Y + 2X^\top X\,\beta.
$$

En annulant l'équation, on obtient :

$$
X^\top (Y - X\hat\beta) = 0
\quad \Longrightarrow \quad
X^\top X\,\hat\beta = X^\top Y.
$$

Donc l'estimateur dans le cas classique est :

$$
\hat\beta_{\text{OLS}} = (X^\top X)^{-1} X^\top Y.
$$

### Cas phylogénétique : erreurs corrélées

Maintenant, les erreurs suivent $\varepsilon \sim \mathcal N(0,\,C)$, donc les observations sont corrélées mais on connait $C$ grâce à l'arbre, qui est la covariance phylogénétique sous MB.

On utilise la décomposition de Cholesky :

$$
C = LL^\top.
$$

On remplace et réécrit en fonction des $L$ :

$$
\tilde Y = L^{-1}Y, 
\qquad 
\tilde X = L^{-1}X, 
\qquad 
\tilde\varepsilon = L^{-1}\varepsilon.
$$

Alors:

$$
\tilde Y = \tilde X\beta + \sigma\tilde\varepsilon,
\qquad
\tilde\varepsilon \sim \mathcal N(0, I).
$$

On a donc un modèle linéaire classique sur les données transformées et on peut appliquer les mêmes méthodes que dans le cas classiques.

#### Estimateurs de $\beta$ dans le cas phylogénétique

On minimise:

$$
\tilde Q(\beta)
=\|\tilde Y - \tilde X\beta\|^2
=(\tilde Y - \tilde X\beta)^\top(\tilde Y - \tilde X\beta).
$$

On développe terme à terme:

$$
\tilde Q(\beta)
= \tilde Y^\top \tilde Y
- 2\,\beta^\top \tilde X^\top \tilde Y
+ \beta^\top \tilde X^\top \tilde X\,\beta.
$$

On dérive par rapport à $\beta$ :

$$
\frac{\partial \tilde Q}{\partial \beta}
= -2\,\tilde X^\top \tilde Y + 2\,\tilde X^\top \tilde X\,\beta.
$$

On cherche à annuler cette équation et on trouve la forme:

$$
\tilde X^\top \tilde X\,\hat\beta
= \tilde X^\top \tilde Y.
$$

Donc en isolant $\beta$ :

$$
\hat\beta
= (\tilde X^\top \tilde X)^{-1} \tilde X^\top \tilde Y.
$$

Avec $\tilde X = L^{-1}X$ et $\tilde Y = L^{-1}Y$ , on remplace:

$$
\tilde X^\top \tilde X
= X^\top (L^{-1})^\top L^{-1} X
= X^\top C^{-1} X,
\qquad
\tilde X^\top \tilde Y
= X^\top (L^{-1})^\top L^{-1} Y
= X^\top C^{-1} Y,
$$

puisque $(L^{-1})^\top L^{-1}=(LL^\top)^{-1}=C^{-1}$ :

On a finalement:

$$
\boxed{
\hat\beta = (X^\top C^{-1}X)^{-1} X^\top C^{-1}Y
}
$$

On a l'estimateur de $\beta$ qui est celui des moindres carrés généralisés

## Estimation de $\sigma^2$ dans la régression phylogénétique

On considère le modèle linéaire :

$$
Y = X\beta + \sigma \varepsilon, \qquad \varepsilon \sim \mathcal N(0,\,C)
$$

où $Y$ est le vecteur des observations, $X$ la matrice de design, $\beta$ le vecteur de paramètres, et $C$ la matrice de covariance phylogénétique.

### Cas classique : erreurs indépendantes

Dans le cas $\varepsilon \sim \mathcal N(0,I)$, on définit le résidu:

$$
\hat r = Y - X\hat\beta_{\text{OLS}},
\qquad \hat\beta_{\text{OLS}} = (X^\top X)^{-1}X^\top Y.
$$

L’estimateur non biaisé de $\sigma^2$ est :

$$
\boxed{\ \hat\sigma^2_{\text{OLS}}
= \frac{1}{n-p}\,\|Y - X\hat\beta_{\text{OLS}}\|^2
= \frac{1}{n-p}\,(Y-X\hat\beta_{\text{OLS}})^\top (Y-X\hat\beta_{\text{OLS}})\ }.
$$

### Cas phylogénétique : erreurs corrélées

Ici $\varepsilon \sim \mathcal N(0,C)$.\
On note la décomposition de Cholesky :

$$
C = LL^\top.
$$

Comme pour l'estimation de $\beta$ on a donc :

$$
\tilde Y = L^{-1}Y, \qquad \tilde X = L^{-1}X, \qquad \tilde\varepsilon = L^{-1}\varepsilon \sim \mathcal N(0,I).
$$

Le modèle devient donc:

$$
\tilde Y = \tilde X\beta + \sigma\tilde\varepsilon.
$$

et l'estimateur de $\beta$ GLS devient:

$$
\hat\beta = (X^\top C^{-1}X)^{-1}X^\top C^{-1}Y.
$$

On définit les résidus :

$$
\hat r = Y - X\hat\beta, 
\qquad 
\tilde r = \tilde Y - \tilde X \hat\beta = L^{-1}\hat r.
$$

Alors :

$$
\hat\sigma^2
= \frac{1}{n-p}\|\tilde r\|^2
= \frac{1}{n-p}\,(\tilde Y - \tilde X\hat\beta)^\top(\tilde Y - \tilde X\hat\beta).
$$

En remplaçant $\tilde r = L^{-1}\hat r$ :

$$
\begin{aligned}
\|\tilde r\|^2
&= (L^{-1}\hat r)^\top(L^{-1}\hat r) \\
&= \hat r^\top (L^{-1})^\top L^{-1} \hat r \\
&= \hat r^\top (LL^\top)^{-1} \hat r \\
&= \hat r^\top C^{-1} \hat r
= (Y - X\hat\beta)^\top C^{-1}(Y - X\hat\beta).
\end{aligned}
$$

et au final on a :

$$
\boxed{
\hat\sigma^2
= \frac{1}{n-p}(Y - X\hat\beta)^\top C^{-1}(Y - X\hat\beta)
= \frac{1}{n-p}\|\tilde Y - \tilde X\hat\beta\|^2
}.
$$

------------------------------------------------------------------------

```{r}
library(ape)
library(phylolm)
```

1)  étape test des formules

on crée un modele et on estime d'abord béta et sigma \^2 avec le package

```{r}
set.seed(3)
n = 1000
x = rnorm(n,3,5)
e = rnorm(n,0,1)
y = 2 + 4*x + e
tree <- rphylo(n, 0.5, 0.1)
names(y) <- names(x) <- tree$tip.label
fit_phylo <- phylolm(y ~ x, phy = tree)
summary(fit_phylo)

```

on estime le béta avec la formule

```{r}
X = cbind(1, x)

c = ape::vcv(tree)
betahat = solve(t(X)%*%solve(c)%*%X)%*%t(X)%*%solve(c)%*%y
betahat
betafor = betahat[2]

```

```{r}
 betatpackage = fit_phylo$coefficients[2]
abs(betafor - betatpackage)
all.equal(betafor,betatpackage , check.attributes = FALSE)

```
Cette vérification montre que le coefficient estimé par notre implémentation est numériquement identique à celui obtenu via le package utilisé .


```{r}
microbenchmark(phylolm(y ~ x, phy = tree))
```

```{r}
microbenchmark(betahat)
```


estimation de sigma\^2 par la formule

```{r}
p = ncol(X)

rownames(X) = names(y)   
r = y - X %*% betahat
sigma2hat <- as.numeric( t(r) %*% solve(c) %*% r / (n-p) )
sigma2hat


```

```{r}
sigmapack = fit_phylo$sigma2
abs(sigma2hat*((n-p)/n) - sigmapack)

```

on voit une différence un peu plus significative pour le sigma\^2 entre celui du package et celui de la formule meme si la différence reste tres petite

phylolm ==\> estimateur de vraisemblance qui est biaisé

maintenant on construit les intervalles de confiance pour beta et sigma

on commence par celui de beta

```{r}
alpha = 0.05
Vb = sigma2hat * solve(t(X) %*% solve(c) %*% X)
se = sqrt(diag(Vb))
lowerbeta = betahat - qt(1-alpha/2, df = n-p) * se
upperbeta = betahat + qt(1-alpha/2, df = n-p) * se
icbeta = cbind(lowerbeta, upperbeta)
icbeta
confint(fit_phylo)
```

on voit que l'intervalle de confiance contient le beta estimé

```{r}


lowersigma <- ((n-p) * sigma2hat) / qchisq(1 - alpha/2, (n-p))
uppersigma <- ((n-p) * sigma2hat) / qchisq(alpha/2, (n-p))

icsigma = cbind(lowersigma , uppersigma)
icsigma


```

on voit que cette intervalle contient sigma

maintenant on test si l'intervalle est bien a 95% de confiance on test sur 100 intervalle il doit avoir environ 95 intervalle qui contient le vrai beta

```{r}

betat = c(3,1.2)
sigmat = 2
m = 50
alpha = 0.05
coverage = 0

for(i in 1:100){

  
  tree <- rphylo(m, 1, 1)

 
  x = rnorm(m)
  X = cbind(1, x)
  rownames(X) <- tree$tip.label


  eps = rTrait(
    n = 1,
    phy = tree,
    model = "BM",
    parameters = list(ancestral.state = 0, sigma2 = sigmat)
  )

  
  y = X %*% betat + eps
  names(y) = tree$tip.label

 
  dat = data.frame(y = y, x = x)
  rownames(dat) = tree$tip.label

  
  fit = phylolm(y ~ x, phy = tree, data = dat)

 
  bhat   = coef(fit)[2]
  se     = summary(fit)$coefficients[2,2]

  
  lowerbeta = bhat - qt(1-alpha/2, df = m-2) * se
  upperbeta = bhat + qt(1-alpha/2, df = m-2) * se

  
  if (betat[2] >= lowerbeta && betat[2] <= upperbeta) {
    coverage = coverage + 1
  }
}

coverage

```
Cette simulation évalue la couverture empirique de l’intervalle de confiance à 95% on a que nos intervalle contient BETA dans presque 95 % des cas . On peut parfois  apercevoir une légere entre la valeur observé et la valeur attendu qui doit etre 95 cela peut etre du a notre faible échantillon qui est seulement de 100 intervalles 



On utilise la fonction rtraitcont pour simuler le vecteur des feuilles sans les trajectoire

```{r}

set.seed(1)
n =20
tree = rphylo(n, birth = 1, death = 0.1)

feuilles = rTraitCont(phy = tree, model = "BM",sigma = sqrt(3),   
  ancestor = FALSE    
)

feuilles

```

Étude de simulation.
Nous réalisons une étude de simulation visant à comparer l’estimation du paramètre β obtenue à partir de données indépendantes en utilisant, d’une part, une régression linéaire classique et, d’autre part, une régression phylogénétique. Dans ce cadre, on s’attend à ce que la régression linéaire classique fournisse une estimation plus précise de β, tandis que la régression phylogénétique, conçue pour corriger la dépendance induite par la structure phylogénétique, peut présenter une variance plus élevée lorsque cette dépendance est absente ou faible.

```{r}

set.seed(123)
rmse <- function(est, true) sqrt(mean((est - true)^2))


n = 50
B = c(1, 5)               
sigma2 = 4
Nsim = 100


reslm      = matrix(0, Nsim, 2)
resphylo   = matrix(0, Nsim, 2)


cover_lm      = rep(0, 2)
cover_phylo   = rep(0, 2)

alpha = 0.05

for(i in 1:Nsim){
  x = rnorm(n)
  X = cbind(1, x)
  e = rnorm(n, 0, sqrt(sigma2))
  y = X %*% B + e

  
  cfit = lm(y ~ x)
  reslm[i, ] = coef(cfit)


  se_lm = summary(cfit)$coefficients[,2]
  lower_lm = coef(cfit) - qt(1-alpha/2, n-2) * se_lm
  upper_lm = coef(cfit) + qt(1-alpha/2, n-2) * se_lm

  cover_lm = cover_lm + (B >= lower_lm & B <= upper_lm)



  tree = rphylo(n, 0.5, 0.5)

  dat <- data.frame(y = y, x = x)
  rownames(dat) <- tree$tip.label

  phfit = phylolm(y ~ x, phy = tree, data = dat)
  resphylo[i, ] = coef(phfit)

 
  se_phy = summary(phfit)$coefficients[,2]
  lower_phy = coef(phfit) - qt(1-alpha/2, n-2) * se_phy
  upper_phy = coef(phfit) + qt(1-alpha/2, n-2) * se_phy

  cover_phylo = cover_phylo + (B >= lower_phy & B <= upper_phy)
}



cat("Couverture des IC \n")
cat("LM      : beta0 =", cover_lm[1]/Nsim, 
    " beta1 =", cover_lm[2]/Nsim, "\n")
cat("phylolm : beta0 =", cover_phylo[1]/Nsim, 
    " beta1 =", cover_phylo[2]/Nsim, "\n")

cat("\n RMSE\n")
rmse_lm_beta0  = rmse(reslm[,1], B[1])
rmse_lm_beta1  = rmse(reslm[,2], B[2])

rmse_phy_beta0 = rmse(resphylo[,1], B[1])
rmse_phy_beta1 = rmse(resphylo[,2], B[2])

cat("RMSE LM beta0      :", rmse_lm_beta0, "\n")
cat("RMSE LM beta1      :", rmse_lm_beta1, "\n")
cat("RMSE phylolm beta0 :", rmse_phy_beta0, "\n")
cat("RMSE phylolm beta1 :", rmse_phy_beta1, "\n")

cat("\n Biais absolus \n")
cat("LM beta1       :", abs(B[2] - mean(reslm[,2])), "\n")
cat("phylolm beta1  :", abs(B[2] - mean(resphylo[,2])), "\n")


```

on a bien que le modele classique estime mieux que le modele phylogénétique - Aucune structure phylogénétique ==\> le modèle classique est meilleur

```{r}
set.seed(123)

n = 50
B = c(1, 5)           
sigma2 = 2
alpha = 0.05
Nsim = 100

reslm      <- matrix(0, Nsim, 2)   
resphylo   <- matrix(0, Nsim, 2)


cover_lm      <- rep(0, 2)
cover_phylo   <- rep(0, 2)


rmse <- function(est, true) sqrt(mean((est - true)^2))

for(i in 1:Nsim){
  tree <- rphylo(n, birth = 0.5, death = 0)

  x = rnorm(n, 0, 4)
  names(x) <- tree$tip.label

  eps = rTrait(
    n = 1, phy = tree, model = "BM",
    parameters = list(ancestral.state = 0, sigma2 = sigma2)
  )


  y = B[1] + B[2]*x + eps
  names(y) <- tree$tip.label

  fit_lm = lm(y ~ x)
  coef_lm = coef(fit_lm)
  reslm[i, ] = coef_lm

  
  se_lm = summary(fit_lm)$coefficients[,2]
  lower_lm = coef_lm - qt(1-alpha/2, df = n-2) * se_lm
  upper_lm = coef_lm + qt(1-alpha/2, df = n-2) * se_lm

  cover_lm = cover_lm + (B >= lower_lm & B <= upper_lm)

  dat = data.frame(y = y, x = x)
  rownames(dat) <- tree$tip.label

  fit_phy = phylolm(y ~ x, phy = tree, data = dat)
  coef_phy = coef(fit_phy)
  resphylo[i, ] = coef_phy

  
  se_phy = summary(fit_phy)$coefficients[,2]
  lower_phy = coef_phy - qt(1-alpha/2, df = n-2) * se_phy
  upper_phy = coef_phy + qt(1-alpha/2, df = n-2) * se_phy

  cover_phylo = cover_phylo + (B >= lower_phy & B <= upper_phy)
}



cat("\n Couverture des IC \n")
cat("LM      : beta0 =", cover_lm[1]/Nsim, " beta1 =", cover_lm[2]/Nsim, "\n")
cat("phylolm : beta0 =", cover_phylo[1]/Nsim, " beta1 =", cover_phylo[2]/Nsim, "\n")

cat("\n RMSE \n")
cat("RMSE LM beta0      :", rmse(reslm[,1],      B[1]), "\n")
cat("RMSE LM beta1      :", rmse(reslm[,2],      B[2]), "\n")
cat("RMSE phylolm beta0 :", rmse(resphylo[,1],   B[1]), "\n")
cat("RMSE phylolm beta1 :", rmse(resphylo[,2],   B[2]), "\n")

cat("\n Biais absolu \n")
cat("LM beta0       :", abs(B[1] - mean(reslm[,1])), "\n")
cat("LM beta1       :", abs(B[2] - mean(reslm[,2])), "\n")
cat("phylolm beta0  :", abs(B[1] - mean(resphylo[,1])), "\n")
cat("phylolm beta1  :", abs(B[2] - mean(resphylo[,2])), "\n")


```

Quand les erreurs suivent un MB sur l'arbre (présence de structure phylogénétique) ==\> modèle phylolm qui est meilleur (correct).

```{r}
library(here)

```

---
title: "PROJET"
format: pdf
editor: visual
author: Tony LI - Saïd BENAISSA
---


## ANOVA classique et ANOVA phylogénétique

On commence par rappeler l’ANOVA non phylogénétique, où les observations sont indépendantes.


## ANOVA classique (erreurs indépendantes)

Le modèle est :

$$
y = X\beta + \sigma \varepsilon,
\qquad
\varepsilon \sim \mathcal N(0, I).
$$

Dans ce cas, les sommes des carrés sont :

-   Somme des carrés expliquée :

$$
SSC = \|\hat y - \bar y\|^2.
$$

-   Somme des carrés résiduels :

$$
SSR = \|y - \hat y\|^2.
$$

La statistique F classique est :

$$
F =
\frac{SSC/(K-1)}{SSR/(n-K)},
\qquad
F \sim F_{K-1,\,n-K}
\quad \text{sous } H_0.
$$


# ANOVA phylogénétique

On part maintenant du modèle phylogénétique :

$$
y = X\beta + \sigma E,
\qquad
E \sim \mathcal N(0, C),
$$

où (C) est la matrice de covariance issue de l’arbre (exemple : Brownian Motion).


## 1. Objectif

Revenir à un modèle avec erreurs indépendantes pour utiliser la même statistique F que dans l’ANOVA classique


## 2. Décomposition de Cholesky

Comme (C) est symétrique définie positive :

$$
C = LL^\top,
$$

où $L$ est triangulaire inférieure et inversible.



## 3. Transformation
On transforme les données :

$$
y^* = L^{-1}y, \qquad X^* = L^{-1}X,
$$

et les erreurs :

$$
E^* = L^{-1}E.
$$

Comme

$$
E \sim \mathcal N(0, C = LL^\top),
$$

on obtient :

$$
E^{*} = L^{-1}E \sim \mathcal{N}(0, I).
$$


## 4. Modèle transformé

On obtient exactement un modèle classique :

$$
y^* = X^*\beta + \sigma E^*,
\qquad
E^* \sim \mathcal N(0, I),
$$

donc les outils de l’ANOVA standard s’appliquent directement.

## 5. Sommes des carrés dans l’espace transformé

Somme des carrés résiduels :

$$
SSR^* = \|y^* - \hat y^*\|^2.
$$

Somme des carrés expliqués :

$$
SSC^* = \|\hat y^* - \bar y^*\|^2.
$$

Statistique F classique :

$$
F^* =
\frac{SSC^*/(K-1)}{SSR^*/(n-K)}.
$$


## 6. Revenir aux données originales : norme pondérée (C\^{-1})

Comme

$$
y^* = L^{-1}y,
$$

alors :

$$
\|y^* - \hat y^*\|^2
= (y - \hat y)^\top (L^{-1})^\top L^{-1}(y - \hat y)
= (y - \hat y)^\top C^{-1}(y - \hat y).
$$

D’où la somme des carrés résiduelle phylogénétique :

$$
SSR_{\text{phylo}}
= (y - \hat y)^\top C^{-1}(y - \hat y).
$$

Et :

$$
SSC_{\text{phylo}}
= (\hat y - \bar y)^\top C^{-1}(\hat y - \bar y).
$$

## 7. Statistique F phylogénétique

Elle est donc :

$$
F =
\frac{SSC_{\text{phylo}}/(K-1)}
     {SSR_{\text{phylo}}/(n-K)}.
$$

Sous l’hypothèse nulle :

$$
F \sim F_{K-1,\,n-K}.
$$

La transformation n’ayant changé ni les degrés de liberté ni la forme du test, la loi F est identique à celle de l’ANOVA classique.




Maintenant on va essayer de comparer l'anova classique et l'anova phylogénétique sur des données phylogénétique  

```{r}
library(ape)
library(phylolm)
library(here)
```

```{r}
i_am("projet_tutoré_rapport.qmd")
```


```{r}
here::here()
```

```{r}

```


```{r}
  tree_emp = read.nexus(here("arbre", "ajb20244-sup-0001.txt"))
```

```{r}
class(tree_emp)
```



```{r}

set.seed(888)

sigma2 = 1        # variance du BM
nsim = 500        # nombre de simulations
B0 = 2            # moyenne sous H0
tree_emp$root.edge = NULL

n = length(tree_emp$tip.label) 


calc_type1 = function(group){

  rej_lm = 0
  rej_phylo = 0

  for(sim in 1:nsim){

    # 1) Simuler bruit BM sur l'arbre fixé
    eps = rTrait(
      n = 1, phy = tree_emp, model = "BM",
      parameters = list(ancestral.state = 0, sigma2 = sigma2)
    )

    eps = eps[tree_emp$tip.label]

    # 2) modèle sous H0
    y = B0 + eps
    names(y) = tree_emp$tip.label

    # 3) ANOVA classique
    fit_lm = lm(y ~ group)
    p_lm = summary(aov(fit_lm))[[1]][["Pr(>F)"]][1]
    if(p_lm < 0.05) rej_lm = rej_lm + 1

    # 4) ANOVA phylogénétique
    dat = data.frame(y = y, group = group)
    fit_phylo = phylolm(y ~ group, phy = tree_emp, data = dat)
    p_phylo = summary(fit_phylo)$coefficients["group2", "p.value"]
    if(p_phylo < 0.05) rej_phylo = rej_phylo + 1
  }

  return(c(
    lm = rej_lm/nsim * 100,
    phylo = rej_phylo/nsim * 100
  ))
}


#groupe cladé

tree <- tree_emp
n <- length(tree$tip.label)

# tous les nœuds internes
internal_nodes <- (n + 1):(n + tree$Nnode)

# nombre de descendants pour chaque nœud
n_desc <- sapply(internal_nodes, function(node) {
  length(extract.clade(tree, node)$tip.label)
})

# nœud le plus proche de n/2
target_node <- internal_nodes[which.min(abs(n_desc - n/2))]
tips_clade <- extract.clade(tree, target_node)$tip.label

# initialisation
group_clade <- rep(2, n)
names(group_clade) <- tree$tip.label

# clade = groupe 1
group_clade[tips_clade] <- 1

group_clade <- factor(group_clade)

# groupe alterné

group_alt = factor(rep(c(1,2), length.out = n))
names(group_alt) = tree_emp$tip.label

#groupe aléatoire
set.seed(888)
group_rand = factor(sample(c(1,2), n, replace = TRUE))
names(group_rand) = tree_emp$tip.label


#calcul erreur de type I

res_clade = calc_type1(group_clade)
res_alt   = calc_type1(group_alt)
res_rand  = calc_type1(group_rand)

#tableau final
results = rbind(
  Clade     = res_clade,
  Alterné   = res_alt,
  Aléatoire = res_rand
)

print("ERREUR DE TYPE I (%)")
print(round(results, 2))


```
Cas Clades
lorsque qu'on répartie les groupes en clades chaque groupe a des valeurs corréllé entre elles mais entre groupe les moyennes sont différentes c'est pour cela que l'anova classique qui ne tient pas comptent des corrélations se trompent beaucoup plus que le modele phylogénétique qui est proche de 5 %

Cas alterné 
avec la répartitions alterné chaque voisin on des groupes différents et comme l'anova classique ne dectecte pas les correlation entre groupe elle ne detecte aucune différence et donc son erreur est égale a 0 contrairement au donné phylogénétique  qui a une erreur proche de 5¨%

Cas random:
du fait de la randomisation on peut considérer comme un mélange des deux cas précédent ce qui fait que l'anova classique a toujours une erreur un peu plus haute que prévu car ce n'est pas le modele adéquate alors que le modele phylogénétique a une erreur proche de 5 %

```{r}
cols = c("red", "blue")[group_clade]
plot(ladderize(tree_emp), tip.color = cols, cex = 0.4)
```



```{r}
cols_alt = c("red", "blue")[group_alt]
plot(ladderize(tree_emp), tip.color = cols_alt, cex = 0.4)
```

```{r}
cols_rand = c("red", "blue")[group_rand]
plot(ladderize(tree_emp), tip.color = cols_rand, cex = 0.4)
```





```{r}
sigma2 = 1        # variance du BM
nsim = 500        # nombre de simulations
B0 = 2            # baseline
delta = 1         # effet du groupe 2 
tree_emp$root.edge = NULL

n = length(tree_emp$tip.label) 



# Fonction PUISSANCE


calc_puissance = function(group){

  rej_lm = 0
  rej_phylo = 0

  for(sim in 1:nsim){

    # 1) Bruit BM sur arbre fixe
    eps = rTrait(
      n = 1, phy = tree_emp, model = "BM",
      parameters = list(ancestral.state = 0, sigma2 = sigma2)
    )

    eps = eps[tree_emp$tip.label]

    # 2) Modèle sous H1 : groupe 2 a un effet delta
    y = B0 + delta*(group == 2) + eps
    names(y) = tree_emp$tip.label

    # 3) ANOVA classique
    fit_lm = lm(y ~ group)
    p_lm = summary(aov(fit_lm))[[1]][["Pr(>F)"]][1]
    if(p_lm < 0.05) rej_lm = rej_lm + 1

    # 4) ANOVA phylogénétique
    dat = data.frame(y = y, group = group)
    fit_phylo = phylolm(y ~ group, phy = tree_emp, data = dat)
    p_phylo = summary(fit_phylo)$coefficients["group2", "p.value"]
    if(p_phylo < 0.05) rej_phylo = rej_phylo + 1
  }

  return(c(
    lm = rej_lm/nsim * 100,
    phylo = rej_phylo/nsim * 100
  ))
}





tree <- tree_emp
n <- length(tree$tip.label)

# tous les nœuds internes
internal_nodes <- (n + 1):(n + tree$Nnode)

# nombre de descendants pour chaque nœud
n_desc <- sapply(internal_nodes, function(node) {
  length(extract.clade(tree, node)$tip.label)
})

# nœud le plus proche de n/2
target_node <- internal_nodes[which.min(abs(n_desc - n/2))]
tips_clade <- extract.clade(tree, target_node)$tip.label

# initialisation
group_clade <- rep(2, n)
names(group_clade) <- tree$tip.label

# clade = groupe 1
group_clade[tips_clade] <- 1

group_clade <- factor(group_clade)


# Groupe alterné 
group_alt = factor(rep(c(1,2), length.out = n))
names(group_alt) = tree_emp$tip.label

# Groupe aléatoire
set.seed(888)
group_rand = factor(sample(c(1,2), n, replace = TRUE))
names(group_rand) = tree_emp$tip.label



# Calcul de la PUISSANCE


res_clade = calc_puissance(group_clade)
res_alt   = calc_puissance(group_alt)
res_rand  = calc_puissance(group_rand)

# Tableau final
results = rbind(
  Clade     = res_clade,
  Alterné   = res_alt,
  Aléatoire = res_rand
)

print("PUISSANCE (%)")
print(round(results, 2))
```

delta = 1 
cas clade :
lm détecte a une grosse puissance car comme c'est le mauvaus modele elle detecte toujours une différence car elle ignore la corrélation
pour phylom du a la variance tres grande entre les clades . il ne détecte pas bien  l'effet du groupe 2  . 

cas alterné :
le modele classique ne détecte presque pas l'effet du groupe 2 contrairement au modele phylogénétique avec une puissance de 86%

cas: aleatoire :
du fait de l'aléatoire on a que le modele phylogénétique est un peu moins puissant que lorsque que lors du cas alterné mais garde quand meme une bonne puissance







```{r}
calc_puissance_phylo = function(delta){

  rej_phylo = 0

  for(sim in 1:nsim){

    # Bruit BM
    eps = rTrait(
      n = 1, phy = tree_emp, model = "BM",
      parameters = list(ancestral.state = 0, sigma2 = sigma2)
    )
    eps = eps[tree_emp$tip.label]

    # Modèle sous H1
    y = B0 + delta*(group_clade == 2) + eps
    names(y) = tree_emp$tip.label

    # ANOVA phylogénétique
    dat = data.frame(y = y, group = group_clade)
    fit_phylo = phylolm(y ~ group, phy = tree_emp, data = dat)

    p_phylo = summary(fit_phylo)$coefficients["group2", "p.value"]

    if(p_phylo < 0.05) rej_phylo = rej_phylo + 1
  }

  return(rej_phylo / nsim)
}
delta_grid = seq(0, 20, by = 2)
puissance_phylo = sapply(delta_grid, calc_puissance_phylo)

results = data.frame(
  delta = delta_grid,
  puissance_phylo = puissance_phylo
)

print(results)


```

```{r}
plot(
  delta_grid, puissance_phylo,
  type = "b", pch = 19,
  xlab = expression(delta),
  ylab = "Puissance (ANOVA phylogénétique)",
  ylim = c(0,1)
)

abline(h = 0.05, lty = 2, col = "red")  # seuil erreur type I

```

