---
title: "PROJET TUTORE M2"
format: html
editor: visual
author: Tony LI - Saïd BENAISSA
---

# Projet tutoré : Mouvement brownien, ANOVA, phylogénie...

## L'arbre phylogénétique

Nous considérons un arbre phylogénétique représentant les relations évolutives entre quatre feuilles issues d’un ancêtre commun A0.

```{r}
library(ape)
library(phytools)
library(dplyr)
library(purrr)
library(ggplot2)


n_tips = 5  # nombre d'espèces terminales
lambda = 1   # taux de spéciation (naissance)
mu = 0       # taux d'extinction (0 = pur birth)

tree= rphylo(n = n_tips, birth = lambda, death = mu)
plot(tree, show.tip.label = TRUE, cex = 0.9, main = "Arbre simulé avec rphylo()")
edgelabels()
nodelabels()
tiplabels()
```

```{r}
simulate_bm <- function(t_e, N) {
  # 1. choose a regular grid on [0,T] with step dt = t_e / N
  dt <- t_e / N
  time <- seq(0, t_e, dt)
  # 2. define data frame and set W_0 = 0
  traj <- data.frame(time = time, value = rep(NA, N+1))
  traj$value[1] <- 0
  # 3. simulate increments dW_n ~ N(0, dt) for 1 <= n <= N
  dW <- rep(NA, N)
  for (n in 1:N) {
    dW[n] <- rnorm(1, mean = 0, sd = sqrt(dt))
  }
  # 4. write W_n = \sum_{i=1}^n dW_i for 1 <= n <= N in the dataframe
  traj$value[-1] <- cumsum(dW)
  # return dataframe
  return(traj)
}
```

```{r}
## choose a time step
dt <- 0.001
## choose starting value
mu <- 1.3
## Create a data frame with the simulated trajectory
dftree <- data.frame(value = numeric(0),       # position of the BM
                     time = numeric(0),        # time elapsed since root
                     edge = numeric(0))        # number of the edge of the tree
## traverse the tree from edge to edge
for (i in 1:nrow(tree$edge)) {
  # simulate a BM starting at (0,0) on the current branch
  t_branch <- tree$edge.length[i]
  N_branch <- floor(t_branch / dt)
  current_BM <- simulate_bm(t_branch, N_branch)
  # find the parent edge of the starting node of the current edge
  parent_edge <- which(tree$edge[i, 1] == tree$edge[, 2])
  # case where current edge does not a parent edge
  if (length(parent_edge) == 0) {
    # add starting value mu
    current_BM$value <- current_BM$value + mu
  } else { # case where current edge do have a parent edge
    # find last value on the parent branch
    dfparent <- dftree[dftree$edge == parent_edge, ]
    last_parent <- dfparent[nrow(dfparent), ]
    # add last value of parent as starting value of the branch
    current_BM$value <- current_BM$value + last_parent$value
    current_BM$time <- current_BM$time + last_parent$time
  }
  # fill in the dataframe
  dfbranch <-  data.frame(value = current_BM$value,
                          time = current_BM$time,
                          edge = i)
  # update dftree
  dftree <- rbind(dftree, dfbranch)
}
```

```{r}
p <- ggplot(dftree, aes(time, value, color = as.factor(edge))) +
  geom_path(linewidth = 1)
p
```

On peut décrire l’évolution d’un caractère quantitatif **T** (par ex. la taille d’une feuille) par un mouvement brownien au cours du temps évolutif **t** (dans le cas de la phylogénie).

Mouvement brownien appliqué à l'évolution d'un caractère continu le long d'un arbre phylogénétique

Le mouvement brownien est un processus stochastique fondamental servant de modèle pour décrire l’évolution aléatoire d’un caractère continu au cours du temps. Il s’agit du processus le plus simple vérifiant les propriétés suivantes : - il est **continu** presque sûrement ; - il possède des accroissements indépendants et stationnaires ; - chaque accroissement est gaussien de moyenne nulle.

On appelle mouvement brownien standard $((B_t)_{t \ge 0})$ le processus stochastique tel que :

\begin{cases}
B_0 = 0,\\[4pt]
B_t - B_s \sim \mathcal{N}(0, t-s), \quad \text{pour } 0 \le s < t,\\[4pt]
\text{les accroissements sont indépendants.}
\end{cases}

## Covariance sous mouvement brownien sur un arbre

On considère un arbre enraciné, où chaque feuille $i$ est reliée à la racine par un chemin de longueur $t_i$.\
Pour deux feuilles $i$ et $j$, on note $t_{ij}$ la longueur du chemin commun depuis la racine jusqu’au MRCA (dernier ancêtre commun).

Le caractère évolue le long de l’arbre selon un mouvement brownien, avec valeur moyenne $\mu$ à la racine.

Modèle utilisé:

On note la valeur du caractère au MRCA de $i$ et $j$ par $Z_{ij}$, alors :

$$
Z_{ij} \sim \mathcal{N}(\mu,\; \sigma^2 t_{ij})
$$

et les valeurs terminales $Y_i$ et $Y_j$ s’écrivent :

$$
Y_i \mid Z_{ij} \sim \mathcal{N}(Z_{ij},\; \sigma^2 (t_i - t_{ij}))
$$

$$
Y_j \mid Z_{ij} \sim \mathcal{N}(Z_{ij},\; \sigma^2 (t_j - t_{ij}))
$$

Autrement dit, on peut écrire :

$$
Y_i = Z_{ij} + \varepsilon_i, \quad \varepsilon_i \sim \mathcal{N}(0,\; \sigma^2 (t_i - t_{ij}))
$$

$$
Y_j = Z_{ij} + \varepsilon_j, \quad \varepsilon_j \sim \mathcal{N}(0,\; \sigma^2 (t_j - t_{ij}))
$$Indépendance des composantes:

Le mouvement brownien nous assure que :

\- $Z_{ij}$ dépend uniquement de l’évolution du caractère sur les branches commune (jusqu’au MRCA),\
- $\varepsilon_i$ dépend des accroissements après la séparation, sur la branche propre à $i$,\
- $\varepsilon_j$ dépend des accroissements après la séparation, sur la branche propre à $j$.

Comme ces ensembles de branches sont disjoints, on a :

$$
Z_{ij} \perp \varepsilon_i, \quad Z_{ij} \perp \varepsilon_j, \quad \varepsilon_i \perp \varepsilon_j
$$Calcul de la covariance:

On développe : $$
\operatorname{Cov}(Y_i, Y_j)
= \operatorname{Cov}(Z_{ij} + \varepsilon_i,\; Z_{ij} + \varepsilon_j)
$$

Par bilinéarité de la covariance : $$
\operatorname{Cov}(Y_i, Y_j)
= \operatorname{Cov}(Z_{ij}, Z_{ij})
+ \operatorname{Cov}(Z_{ij}, \varepsilon_j)
+ \operatorname{Cov}(\varepsilon_i, Z_{ij})
+ \operatorname{Cov}(\varepsilon_i, \varepsilon_j)
$$

Les trois derniers termes sont nuls par indépendance (vu en haut): $$
\operatorname{Cov}(Z_{ij}, \varepsilon_j)
= \operatorname{Cov}(\varepsilon_i, Z_{ij})
= \operatorname{Cov}(\varepsilon_i, \varepsilon_j)
= 0.
$$

Il reste donc : $$
\operatorname{Cov}(Y_i, Y_j)
= \operatorname{Var}(Z_{ij})
= \sigma^2 t_{ij}.
$$Conclusion

$$
\operatorname{Cov}(Y_i, Y_j) = \sigma^2\, t_{ij}
$$

Etape suivante formule beta etc

## Estimation de $\beta$ dans la régression phylogénétique

On considère le modèle linéaire :

$$
Y = X\beta + \sigma \varepsilon, 
\qquad \varepsilon \sim \mathcal N(0,\,C)
$$

où $Y$ est le vecteur des observations, $X$ la matrice de design, $\beta$ le vecteur de paramètres, et $C$ la matrice de covariance phylogénétique.

### Cas classique : erreurs indépendantes

Si $\varepsilon \sim \mathcal N(0, I)$, alors l'estimation par moindres carrés consiste à minimiser:

$$
Q(\beta)=\|Y - X\beta\|^2
= (Y - X\beta)^\top (Y - X\beta).
$$

On développe terme à terme:

$$
Q(\beta) = Y^\top Y - 2\beta^\top X^\top Y + \beta^\top X^\top X\,\beta.
$$

On dérive par rapport à $\beta$ :

$$
\frac{\partial Q}{\partial \beta}
= -2X^\top Y + 2X^\top X\,\beta.
$$

En annulant l'équation, on obtient :

$$
X^\top (Y - X\hat\beta) = 0
\quad \Longrightarrow \quad
X^\top X\,\hat\beta = X^\top Y.
$$

Donc l'estimateur dans le cas classique est :

$$
\hat\beta_{\text{OLS}} = (X^\top X)^{-1} X^\top Y.
$$

### Cas phylogénétique : erreurs corrélées

Maintenant, les erreurs suivent $\varepsilon \sim \mathcal N(0,\,C)$, donc les observations sont corrélées mais on connait $C$ grâce à l'arbre, qui est la covariance phylogénétique sous MB.

On utilise la décomposition de Cholesky :

$$
C = LL^\top.
$$

On remplace et réécrit en fonction des $L$ :

$$
\tilde Y = L^{-1}Y, 
\qquad 
\tilde X = L^{-1}X, 
\qquad 
\tilde\varepsilon = L^{-1}\varepsilon.
$$

Alors:

$$
\tilde Y = \tilde X\beta + \sigma\tilde\varepsilon,
\qquad
\tilde\varepsilon \sim \mathcal N(0, I).
$$

On a donc un modèle linéaire classique sur les données transformées et on peut appliquer les mêmes méthodes que dans le cas classiques.

#### Estimateurs de $\beta$ dans le cas phylogénétique

On minimise:

$$
\tilde Q(\beta)
=\|\tilde Y - \tilde X\beta\|^2
=(\tilde Y - \tilde X\beta)^\top(\tilde Y - \tilde X\beta).
$$

On développe terme à terme:

$$
\tilde Q(\beta)
= \tilde Y^\top \tilde Y
- 2\,\beta^\top \tilde X^\top \tilde Y
+ \beta^\top \tilde X^\top \tilde X\,\beta.
$$

On dérive par rapport à $\beta$ :

$$
\frac{\partial \tilde Q}{\partial \beta}
= -2\,\tilde X^\top \tilde Y + 2\,\tilde X^\top \tilde X\,\beta.
$$

On cherche à annuler cette équation et on trouve la forme:

$$
\tilde X^\top \tilde X\,\hat\beta
= \tilde X^\top \tilde Y.
$$

Donc en isolant $\beta$ :

$$
\hat\beta
= (\tilde X^\top \tilde X)^{-1} \tilde X^\top \tilde Y.
$$

Avec $\tilde X = L^{-1}X$ et $\tilde Y = L^{-1}Y$ , on remplace:

$$
\tilde X^\top \tilde X
= X^\top (L^{-1})^\top L^{-1} X
= X^\top C^{-1} X,
\qquad
\tilde X^\top \tilde Y
= X^\top (L^{-1})^\top L^{-1} Y
= X^\top C^{-1} Y,
$$

puisque $(L^{-1})^\top L^{-1}=(LL^\top)^{-1}=C^{-1}$ :

On a finalement:

$$
\boxed{
\hat\beta = (X^\top C^{-1}X)^{-1} X^\top C^{-1}Y
}
$$

On a l'estimateur de $\beta$ qui est celui des moindres carrés généralisés

## Estimation de $\sigma^2$ dans la régression phylogénétique

On considère le modèle linéaire :

$$
Y = X\beta + \sigma \varepsilon, \qquad \varepsilon \sim \mathcal N(0,\,C)
$$

où $Y$ est le vecteur des observations, $X$ la matrice de design, $\beta$ le vecteur de paramètres, et $C$ la matrice de covariance phylogénétique.

### Cas classique : erreurs indépendantes

Dans le cas $\varepsilon \sim \mathcal N(0,I)$, on définit le résidu:

$$
\hat r = Y - X\hat\beta_{\text{OLS}},
\qquad \hat\beta_{\text{OLS}} = (X^\top X)^{-1}X^\top Y.
$$

L’estimateur non biaisé de $\sigma^2$ est :

$$
\boxed{\ \hat\sigma^2_{\text{OLS}}
= \frac{1}{n-p}\,\|Y - X\hat\beta_{\text{OLS}}\|^2
= \frac{1}{n-p}\,(Y-X\hat\beta_{\text{OLS}})^\top (Y-X\hat\beta_{\text{OLS}})\ }.
$$

### Cas phylogénétique : erreurs corrélées

Ici $\varepsilon \sim \mathcal N(0,C)$.\
On note la décomposition de Cholesky :

$$
C = LL^\top.
$$

Comme pour l'estimation de $\beta$ on a donc :

$$
\tilde Y = L^{-1}Y, \qquad \tilde X = L^{-1}X, \qquad \tilde\varepsilon = L^{-1}\varepsilon \sim \mathcal N(0,I).
$$

Le modèle devient donc:

$$
\tilde Y = \tilde X\beta + \sigma\tilde\varepsilon.
$$

et l'estimateur de $\beta$ GLS devient:

$$
\hat\beta = (X^\top C^{-1}X)^{-1}X^\top C^{-1}Y.
$$

On définit les résidus :

$$
\hat r = Y - X\hat\beta, 
\qquad 
\tilde r = \tilde Y - \tilde X \hat\beta = L^{-1}\hat r.
$$

Alors :

$$
\hat\sigma^2
= \frac{1}{n-p}\|\tilde r\|^2
= \frac{1}{n-p}\,(\tilde Y - \tilde X\hat\beta)^\top(\tilde Y - \tilde X\hat\beta).
$$

En remplaçant $\tilde r = L^{-1}\hat r$ :

$$
\begin{aligned}
\|\tilde r\|^2
&= (L^{-1}\hat r)^\top(L^{-1}\hat r) \\
&= \hat r^\top (L^{-1})^\top L^{-1} \hat r \\
&= \hat r^\top (LL^\top)^{-1} \hat r \\
&= \hat r^\top C^{-1} \hat r
= (Y - X\hat\beta)^\top C^{-1}(Y - X\hat\beta).
\end{aligned}
$$

et au final on a :

$$
\boxed{
\hat\sigma^2
= \frac{1}{n-p}(Y - X\hat\beta)^\top C^{-1}(Y - X\hat\beta)
= \frac{1}{n-p}\|\tilde Y - \tilde X\hat\beta\|^2
}.
$$

------------------------------------------------------------------------

```{r}
library(ape)
library(phylolm)
```

1)  étape test des formules

on crée un modele et on estime d'abord béta et sigma \^2 avec le package

```{r}
set.seed(3)
n = 1000
x = rnorm(n,3,5)
e = rnorm(n,0,1)
y = 2 + 4*x + e
tree <- rphylo(n, 0.5, 0.1)
names(y) <- names(x) <- tree$tip.label
fit_phylo <- phylolm(y ~ x, phy = tree)
summary(fit_phylo)

```

on estime le béta avec la formule

```{r}
X = cbind(1, x)

c = ape::vcv(tree)
betahat = solve(t(X)%*%solve(c)%*%X)%*%t(X)%*%solve(c)%*%y
betahat
betafor = betahat[2]

```

```{r}
 betatpackage = fit_phylo$coefficients[2]
abs(betafor - betatpackage)
all.equal(betafor,betatpackage , check.attributes = FALSE)

```

```{r}
microbenchmark(phylolm(y ~ x, phy = tree))
```

```{r}
microbenchmark(betahat)
```

on compare le beta avec le coefficient du package et on voit que c'est le meme car leur différence est tres proche de 0

estimation de sigma\^2 par la formule

```{r}
p = ncol(X)

rownames(X) = names(y)   
r = y - X %*% betahat
sigma2hat <- as.numeric( t(r) %*% solve(c) %*% r / (n-p) )
sigma2hat


```

```{r}
sigmapack = fit_phylo$sigma2
abs(sigma2hat*((n-p)/n) - sigmapack)

```

on voit une différence un peu plus significative pour le sigma\^2 entre celui du package et celui de la formule meme si la différence reste tres petite

phylolm ==\> estimateur de vraisemblance qui est biaisé

maintenant on construit les intervalles de confiance pour beta et sigma

on commence par celui de beta

```{r}
alpha = 0.05
Vb = sigma2hat * solve(t(X) %*% solve(c) %*% X)
se = sqrt(diag(Vb))
lowerbeta = betahat - qt(1-alpha/2, df = n-p) * se
upperbeta = betahat + qt(1-alpha/2, df = n-p) * se
icbeta = cbind(lowerbeta, upperbeta)
icbeta
confint(fit_phylo)
```

on voit que l'intervalle de confiance contient le beta estimé

```{r}


lowersigma <- ((n-p) * sigma2hat) / qchisq(1 - alpha/2, (n-p))
uppersigma <- ((n-p) * sigma2hat) / qchisq(alpha/2, (n-p))

icsigma = cbind(lowersigma , uppersigma)
icsigma


```

on voit que cette intervalle contient sigma

maintenant on test si l'intervalle est bien a 95% de confiance on test sur 100 intervalle il doit avoir environ 95 intervalle qui contient le vrai beta

```{r}

betat = c(3,1.2)
sigmat = 2
m = 50
alpha = 0.05
coverage = 0

for(i in 1:100){

  # arbre phylogénétique simulé
  tree <- rphylo(m, 1, 1)

  # simulateur covariable
  x = rnorm(m)
  X = cbind(1, x)
  rownames(X) <- tree$tip.label

  # bruit brownien (phylogénétique)
  eps = rTrait(
    n = 1,
    phy = tree,
    model = "BM",
    parameters = list(ancestral.state = 0, sigma2 = sigmat)
  )

  # variable réponse
  y = X %*% betat + eps
  names(y) = tree$tip.label

  # données pour phylolm
  dat = data.frame(y = y, x = x)
  rownames(dat) = tree$tip.label

  # estimation complète via phylolm
  fit = phylolm(y ~ x, phy = tree, data = dat)

  # récupère beta chapeau et erreur standard
  bhat   = coef(fit)[2]
  se     = summary(fit)$coefficients[2,2]

  # intervalle de confiance
  lowerbeta = bhat - qt(1-alpha/2, df = m-2) * se
  upperbeta = bhat + qt(1-alpha/2, df = m-2) * se

  # couverture
  if (betat[2] >= lowerbeta && betat[2] <= upperbeta) {
    coverage = coverage + 1
  }
}

coverage

```

on utilise la fonction rtraitcont pour simuler le vecteur des feuilles sans les trajectoire

```{r}
?rTraitCont
set.seed(1)
n =20
tree = rphylo(n, birth = 1, death = 0.1)

feuilles = rTraitCont(phy = tree, model = "BM",sigma = sqrt(3),   
  ancestor = FALSE    
)

feuilles

```

étude de simulation on réalise une étude de simulation ou on compare l'estimation de béta pour des donnée classique entre la régression classique et la régression phylogénétique on doit normalement s'attendre a ce que la régression classique estime mieux le béta que la régression phylogénétique

```{r}

set.seed(123)
rmse <- function(est, true) sqrt(mean((est - true)^2))


n = 50
B = c(1, 5)               # beta0, beta1
sigma2 = 4
Nsim = 100

# stocker les beta0 et beta1
reslm      = matrix(0, Nsim, 2)
resphylo   = matrix(0, Nsim, 2)

# stocker la couverture
cover_lm      = rep(0, 2)
cover_phylo   = rep(0, 2)

alpha = 0.05

for(i in 1:Nsim){
  x = rnorm(n)
  X = cbind(1, x)
  e = rnorm(n, 0, sqrt(sigma2))
  y = X %*% B + e

  # Fit LM
  cfit = lm(y ~ x)
  reslm[i, ] = coef(cfit)

  # IC pour LM
  se_lm = summary(cfit)$coefficients[,2]
  lower_lm = coef(cfit) - qt(1-alpha/2, n-2) * se_lm
  upper_lm = coef(cfit) + qt(1-alpha/2, n-2) * se_lm

  cover_lm = cover_lm + (B >= lower_lm & B <= upper_lm)

  # 2) Données phylogénétiques

  tree = rphylo(n, 0.5, 0.5)

  dat <- data.frame(y = y, x = x)
  rownames(dat) <- tree$tip.label

  phfit = phylolm(y ~ x, phy = tree, data = dat)
  resphylo[i, ] = coef(phfit)

  # IC phylolm
  se_phy = summary(phfit)$coefficients[,2]
  lower_phy = coef(phfit) - qt(1-alpha/2, n-2) * se_phy
  upper_phy = coef(phfit) + qt(1-alpha/2, n-2) * se_phy

  cover_phylo = cover_phylo + (B >= lower_phy & B <= upper_phy)
}



cat("Couverture des IC \n")
cat("LM      : beta0 =", cover_lm[1]/Nsim, 
    " beta1 =", cover_lm[2]/Nsim, "\n")
cat("phylolm : beta0 =", cover_phylo[1]/Nsim, 
    " beta1 =", cover_phylo[2]/Nsim, "\n")

cat("\n RMSE\n")
rmse_lm_beta0  = rmse(reslm[,1], B[1])
rmse_lm_beta1  = rmse(reslm[,2], B[2])

rmse_phy_beta0 = rmse(resphylo[,1], B[1])
rmse_phy_beta1 = rmse(resphylo[,2], B[2])

cat("RMSE LM beta0      :", rmse_lm_beta0, "\n")
cat("RMSE LM beta1      :", rmse_lm_beta1, "\n")
cat("RMSE phylolm beta0 :", rmse_phy_beta0, "\n")
cat("RMSE phylolm beta1 :", rmse_phy_beta1, "\n")

cat("\n Biais absolus \n")
cat("LM beta1       :", abs(B[2] - mean(reslm[,2])), "\n")
cat("phylolm beta1  :", abs(B[2] - mean(resphylo[,2])), "\n")


```

on a bien que le modele classique estime mieux que le modele phylogénétique - Aucune structure phylogénétique ==\> le modèle classique est meilleur

```{r}
set.seed(123)

n = 50
B = c(1, 5)             # beta0, beta1
sigma2 = 2
alpha = 0.05
Nsim = 100

# stockage des coefficients estimés
reslm      <- matrix(0, Nsim, 2)   # beta0 , beta1
resphylo   <- matrix(0, Nsim, 2)

# couverture
cover_lm      <- rep(0, 2)
cover_phylo   <- rep(0, 2)

# fonction RMSE
rmse <- function(est, true) sqrt(mean((est - true)^2))

for(i in 1:Nsim){
  tree <- rphylo(n, birth = 0.5, death = 0)

  x = rnorm(n, 0, 4)
  names(x) <- tree$tip.label

  eps = rTrait(
    n = 1, phy = tree, model = "BM",
    parameters = list(ancestral.state = 0, sigma2 = sigma2)
  )


  y = B[1] + B[2]*x + eps
  names(y) <- tree$tip.label

  fit_lm = lm(y ~ x)
  coef_lm = coef(fit_lm)
  reslm[i, ] = coef_lm

  # IC LM
  se_lm = summary(fit_lm)$coefficients[,2]
  lower_lm = coef_lm - qt(1-alpha/2, df = n-2) * se_lm
  upper_lm = coef_lm + qt(1-alpha/2, df = n-2) * se_lm

  cover_lm = cover_lm + (B >= lower_lm & B <= upper_lm)

  dat = data.frame(y = y, x = x)
  rownames(dat) <- tree$tip.label

  fit_phy = phylolm(y ~ x, phy = tree, data = dat)
  coef_phy = coef(fit_phy)
  resphylo[i, ] = coef_phy

  # IC phylolm
  se_phy = summary(fit_phy)$coefficients[,2]
  lower_phy = coef_phy - qt(1-alpha/2, df = n-2) * se_phy
  upper_phy = coef_phy + qt(1-alpha/2, df = n-2) * se_phy

  cover_phylo = cover_phylo + (B >= lower_phy & B <= upper_phy)
}



cat("\n Couverture des IC \n")
cat("LM      : beta0 =", cover_lm[1]/Nsim, " beta1 =", cover_lm[2]/Nsim, "\n")
cat("phylolm : beta0 =", cover_phylo[1]/Nsim, " beta1 =", cover_phylo[2]/Nsim, "\n")

cat("\n RMSE \n")
cat("RMSE LM beta0      :", rmse(reslm[,1],      B[1]), "\n")
cat("RMSE LM beta1      :", rmse(reslm[,2],      B[2]), "\n")
cat("RMSE phylolm beta0 :", rmse(resphylo[,1],   B[1]), "\n")
cat("RMSE phylolm beta1 :", rmse(resphylo[,2],   B[2]), "\n")

cat("\n Biais absolu \n")
cat("LM beta0       :", abs(B[1] - mean(reslm[,1])), "\n")
cat("LM beta1       :", abs(B[2] - mean(reslm[,2])), "\n")
cat("phylolm beta0  :", abs(B[1] - mean(resphylo[,1])), "\n")
cat("phylolm beta1  :", abs(B[2] - mean(resphylo[,2])), "\n")


```

Quand les erreurs suivent un MB sur l'arbre (présence de structure phylogénétique) ==\> modèle phylolm qui est meilleur (correct).
